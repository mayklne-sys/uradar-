<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AudioRadarFFT — HTML версия проекта</title>
  <style>
    :root{--bg:#0b1220;--ink:#e6f0ff;--muted:#9fb0d0;--card:#0f182a;--line:#1a2744;--a1:#4fd1c5;--a2:#60a5fa;}
    *{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto}
    a{color:var(--a1);text-decoration:none} a:hover{text-decoration:underline}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    .hero{display:grid;grid-template-columns:1.25fr 1fr;gap:20px;align-items:center}
    @media(max-width:920px){.hero{grid-template-columns:1fr}}
    h1{margin:0 0 6px;font-size:40px}
    .tag{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(96,165,250,.15);border:1px solid rgba(96,165,250,.35);color:#cfe5ff;font-size:13px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px}
    .btns{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
    .btn{display:inline-flex;gap:10px;align-items:center;padding:10px 14px;border-radius:12px;background:#162033;border:1px solid rgba(255,255,255,.14);color:#e6f0ff}
    .btn.primary{background:linear-gradient(90deg,var(--a1),var(--a2));color:#0b1220;border:none;font-weight:700}
    .muted{color:var(--muted)}
    .grid{display:grid;gap:16px}
    .grid.cols-3{grid-template-columns:repeat(3,1fr)}
    .grid.cols-2{grid-template-columns:repeat(2,1fr)}
    pre{background:#0a1322;border:1px solid #13213a;border-radius:12px;padding:12px;overflow:auto}
    code,pre{font-family:ui-monospace,Menlo,Consolas,monospace}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0a1322;border:1px solid #13213a;padding:2px 6px;border-radius:6px}
    .foot{margin-top:28px;text-align:center;color:var(--muted);font-size:13px}
    details{border:1px solid var(--line);border-radius:12px;padding:10px;background:#0a1322}
    details>summary{cursor:pointer;font-weight:600;color:#cfe5ff}
    canvas{display:block;width:100%;height:auto;background:#08101d;border-radius:12px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <div>
        <span class="tag">Android • Kotlin • DSP • FFT • HTML‑демо</span>
        <h1>AudioRadarFFT — HTML версия</h1>
        <p class="muted">Веб‑демонстрация (визуализация радара) + документация проекта Android/Kotlin с FFT‑корреляцией. Ниже — инструкции, ссылки и исходные коды в разворачиваемых блоках.</p>
        <div class="btns">
          <a class="btn primary" href="AudioRadarFFT_Complete_Project.zip">Скачать Android‑проект (ZIP)</a>
          <a class="btn" href="#build">Сборка через Gradle</a>
          <a class="btn" href="#code">Исходники (Kotlin)</a>
        </div>
      </div>
      <div class="card"><canvas id="radar" width="560" height="340"></canvas></div>
    </div>

    <div class="grid cols-3" style="margin-top:22px">
      <div class="card"><b>DSP</b><br><span class="muted">Чирп 18→16 кГц → BPF ×2 (16–18 кГц) → FFT‑corr → пик → расстояние.</span></div>
      <div class="card"><b>Скорость</b><br><span class="muted">O(N log N) вместо наивной корреляции. Буферы переиспользуются.</span></div>
      <div class="card"><b>Практика</b><br><span class="muted">SNR по коррелограмме; фоллбэк аудиоисточника: UNPROCESSED→VR→MIC.</span></div>
    </div>

    <div class="card" id="build" style="margin-top:24px">
      <h2>Сборка проекта (Gradle)</h2>
      <div class="grid cols-2">
        <div>
          <h3>Android Studio</h3>
          <ol>
            <li>Распакуйте <span class="kbd">AudioRadarFFT_Complete_Project.zip</span>.</li>
            <li><span class="kbd">File → Open…</span> → выберите папку проекта.</li>
            <li>Дождитесь синхронизации Gradle.</li>
            <li><span class="kbd">Build → Build APK(s)</span> → <span class="kbd">app/build/outputs/apk/debug/app-debug.apk</span></li>
          </ol>
        </div>
        <div>
          <h3>CLI</h3>
          <pre><code>./gradlew clean
./gradlew assembleDebug
./gradlew assembleRelease   # релиз, нужен keystore
</code></pre>
          <p class="muted">Требования: JDK 17, Android SDK 34, Kotlin 1.9, AGP 8.5.</p>
        </div>
      </div>
    </div>

    <div class="card" id="code" style="margin-top:24px">
      <h2>Ключевые исходники (Kotlin)</h2>

      <details>
        <summary>FFT.kt — Cooley–Tukey radix‑2 (итеративный)</summary>
        <pre><code>package com.example.audioradar
import kotlin.math.*

object FFT {
    fun fft(re: DoubleArray, im: DoubleArray) {
        val n = re.size
        require(n == im.size && n and (n - 1) == 0) { "size must be power of two" }
        var j = 0
        for (i in 1 until n) {
            var bit = n shr 1
            while (j and bit != 0) { j = j xor bit; bit = bit shr 1 }
            j = j or bit
            if (i &lt; j) {
                val tr = re[i]; val ti = im[i]
                re[i] = re[j]; im[i] = im[j]
                re[j] = tr; im[j] = ti
            }
        }
        var len = 2
        while (len &lt;= n) {
            val ang = -2.0 * Math.PI / len
            val wlenCos = cos(ang); val wlenSin = sin(ang)
            for (i in 0 until n step len) {
                var wCos = 1.0; var wSin = 0.0
                for (k in 0 until len / 2) {
                    val uRe = re[i + k]; val uIm = im[i + k]
                    val vRe = re[i + k + len/2] * wCos - im[i + k + len/2] * wSin
                    val vIm = re[i + k + len/2] * wSin + im[i + k + len/2] * wCos
                    re[i + k] = uRe + vRe; im[i + k] = uIm + vIm
                    re[i + k + len/2] = uRe - vRe; im[i + k + len/2] = uIm - vIm
                    val tCos = wCos * wlenCos - wSin * wlenSin
                    wSin = wCos * wlenSin + wSin * wlenCos
                    wCos = tCos
                }
            }
            len = len shl 1
        }
    }
    fun ifft(re: DoubleArray, im: DoubleArray) {
        for (i in im.indices) im[i] = -im[i]
        fft(re, im)
        val nInv = 1.0 / re.size
        for (i in re.indices) { re[i] *= nInv; im[i] = -im[i] * nInv }
    }
}</code></pre>
      </details>

      <details>
        <summary>BiquadBandpass.kt — полосовой фильтр</summary>
        <pre><code>package com.example.audioradar
import kotlin.math.*

class BiquadBandpass(fs: Int, f0: Double, q: Double) {
    private val a0: Double; private val a1: Double; private val a2: Double
    private val b0: Double; private val b1: Double; private val b2: Double
    private var x1 = 0.0; private var x2 = 0.0; private var y1 = 0.0; private var y2 = 0.0
    init {
        val w0 = 2.0 * Math.PI * f0 / fs
        val alpha = sin(w0) / (2.0 * q)
        val cosw = cos(w0)
        b0 =   q * alpha
        b1 =   0.0
        b2 =  -q * alpha
        val a0n = 1.0 + alpha
        a1 =  -2.0 * cosw
        a2 =   1.0 - alpha
        a0 = a0n
    }
    fun process(x: Double): Double {
        val y = (b0/a0)*x + (b1/a0)*x1 + (b2/a0)*x2 - (a1/a0)*y1 - (a2/a0)*y2
        x2 = x1; x1 = x; y2 = y1; y1 = y
        return y
    }
    fun processBlock(input: ShortArray): DoubleArray {
        val out = DoubleArray(input.size)
        for (i in input.indices) out[i] = process(input[i].toDouble())
        return out
    }
}</code></pre>
      </details>

      <details>
        <summary>FftCorrelator.kt — корреляция в спектре + SNR</summary>
        <pre><code>package com.example.audioradar
import kotlin.math.*

class FftCorrelator(
    private val fs: Int,
    template: ShortArray,
    private val maxLag: Int,
    private val minLagMs: Double = 3.0
) {
    private val n: Int
    private val Hre: DoubleArray
    private val Him: DoubleArray
    private val tplEnergy: Double
    private val re: DoubleArray
    private val im: DoubleArray
    private val corr: DoubleArray
    private val minLag: Int

    init {
        val tpl = template.map { it.toDouble() }.toDoubleArray()
        tplEnergy = max(1e-9, tpl.sumOf { it * it })
        var nPow2 = 1
        while (nPow2 &lt; template.size + maxLag) nPow2 = nPow2 shl 1
        n = nPow2
        val tre = DoubleArray(n); val tim = DoubleArray(n)
        System.arraycopy(tpl, 0, tre, 0, tpl.size)
        FFT.fft(tre, tim)
        Hre = DoubleArray(n) { tre[it] }
        Him = DoubleArray(n) { -tim[it] }
        re = DoubleArray(n); im = DoubleArray(n); corr = DoubleArray(n)
        minLag = (minLagMs * 1e-3 * fs).toInt().coerceAtLeast(0)
    }

    fun correlateWithTrace(frame: DoubleArray): Triple&lt;Int, Double, DoubleArray&gt; {
        java.util.Arrays.fill(re, 0.0); java.util.Arrays.fill(im, 0.0)
        val m = min(frame.size, n)
        val denom = (m - 1.0).coerceAtLeast(1.0)
        for (i in 0 until m) {
            val w = 0.5 * (1 - cos(2.0 * Math.PI * i / denom))
            re[i] = frame[i] * w
        }
        FFT.fft(re, im)
        for (i in 0 until n) {
            val r = re[i]*Hre[i] - im[i]*Him[i]
            val ii = re[i]*Him[i] + im[i]*Hre[i]
            re[i] = r; im[i] = ii
        }
        FFT.ifft(re, im)
        System.arraycopy(re, 0, corr, 0, n)

        val searchStart = minLag
        val searchEnd = maxLag.coerceAtMost(n - 1)
        var bestLag = searchStart; var best = Double.NEGATIVE_INFINITY
        for (lag in searchStart..searchEnd) {
            val v = corr[lag]
            if (v &gt; best) { best = v; bestLag = lag }
        }
        val frameEnergy = max(1e-9, frame.sumOf { it * it })
        val score = best / sqrt(frameEnergy * tplEnergy)
        return Triple(bestLag, score, corr)
    }

    fun snrDbFromCorr(corr: DoubleArray, peakIdx: Int, guard: Int = 64): Double {
        val peak = kotlin.math.abs(corr[peakIdx]) + 1e-12
        var noiseSum = 0.0; var cnt = 0
        for (i in corr.indices) {
            if (i in (peakIdx-guard)..(peakIdx+guard)) continue
            noiseSum += kotlin.math.abs(corr[i]); cnt++
        }
        val noise = (noiseSum / kotlin.math.max(1, cnt)) + 1e-12
        return 20.0 * kotlin.math.log10(peak / noise)
    }
}</code></pre>
      </details>

      <details>
        <summary>MainActivity.kt — логика приложения + фоллбэк источника</summary>
        <pre><code>package com.example.audioradar

import android.Manifest
import android.content.Context
import android.media.*
import android.os.*
import androidx.appcompat.app.AppCompatActivity
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.camera.core.CameraSelector
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.core.content.ContextCompat
import com.example.audioradar.databinding.ActivityMainBinding
import kotlin.concurrent.thread

class MainActivity : AppCompatActivity() {
    private lateinit var b: ActivityMainBinding
    private var txThread: Thread? = null
    private var rxThread: Thread? = null
    @Volatile private var running = false

    private val fs = 48_000
    private val c = 343.0
    private val maxRangeM = 4.0
    private val maxLag = (2 * maxRangeM / c * fs).toInt()
    private val probe = chirp(fs = fs, durMs = 20, fStart = 18_000.0, fEnd = 16_000.0)

    private lateinit var bpf1: BiquadBandpass
    private lateinit var bpf2: BiquadBandpass
    private lateinit var correlator: FftCorrelator

    private val requestPerms = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { granted ->
        val ok = granted[Manifest.permission.RECORD_AUDIO] == true &&
                 granted[Manifest.permission.CAMERA] == true
        if (ok) startCamera() else Toast.makeText(this, "Нужны разрешения", Toast.LENGTH_SHORT).show()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        b = ActivityMainBinding.inflate(layoutInflater)
        setContentView(b.root)

        bpf1 = BiquadBandpass(fs, f0 = 18_000.0, q = 6.0)
        bpf2 = BiquadBandpass(fs, f0 = 17_000.0, q = 6.0)
        correlator = FftCorrelator(fs, template = probe, maxLag = maxLag, minLagMs = 3.0)

        requestPerms.launch(arrayOf(Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA))
        b.btnStart.setOnClickListener { startRadar() }
        b.btnStop.setOnClickListener { stopRadar() }
    }

    private fun startCamera() {
        val providerFuture = ProcessCameraProvider.getInstance(this)
        providerFuture.addListener({
            val provider = providerFuture.get()
            val preview = androidx.camera.core.Preview.Builder().build().apply {
                setSurfaceProvider(b.previewView.surfaceProvider)
            }
            provider.unbindAll()
            provider.bindToLifecycle(this, CameraSelector.DEFAULT_BACK_CAMERA, preview)
        }, ContextCompat.getMainExecutor(this))
    }

    private fun chooseAudioSource(ctx: Context): Int {
        val supportsUnprocessed = if (Build.VERSION.SDK_INT >= 24) {
            val am = ctx.getSystemService(Context.AUDIO_SERVICE) as AudioManager
            am.getProperty(AudioManager.PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED) != null
        } else false
        return if (supportsUnprocessed) MediaRecorder.AudioSource.UNPROCESSED
               else MediaRecorder.AudioSource.VOICE_RECOGNITION
    }

    private fun startRadar() {
        if (running) return
        running = true
        b.txtStatus.text = "Сканирую…"

        txThread = thread(start = true, name = "tx") {
            val track = AudioTrack(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build(),
                AudioFormat.Builder()
                    .setSampleRate(fs)
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_MONO).build(),
                probe.size * 4, AudioTrack.MODE_STREAM, AudioManager.AUDIO_SESSION_ID_GENERATE
            )
            val gap = ShortArray(probe.size)
            track.play()
            while (running) { track.write(probe, 0, probe.size); track.write(gap, 0, gap.size) }
            track.stop(); track.release()
        }

        rxThread = thread(start = true, name = "rx") {
            val src = chooseAudioSource(this@MainActivity)
            val minBuf = AudioRecord.getMinBufferSize(
                fs, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT
            ).coerceAtLeast(4 * 1024)
            val rec = try {
                AudioRecord(src, fs, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, minBuf * 2)
                    .also { if (it.state != AudioRecord.STATE_INITIALIZED) throw IllegalStateException() }
            } catch (_: Throwable) {
                AudioRecord(MediaRecorder.AudioSource.MIC, fs, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, minBuf * 2)
            }
            val buf = ShortArray(minBuf)
            rec.startRecording()
            while (running) {
                val n = rec.read(buf, 0, buf.size)
                if (n > 0) {
                    val x1 = bpf1.processBlock(buf)
                    val x2 = DoubleArray(x1.size) { i -> bpf2.process(x1[i]) }
                    val (lag, score, corr) = correlator.correlateWithTrace(x2)
                    val dt = lag.toDouble() / fs
                    val d = 0.5 * c * dt
                    val snrDb = correlator.snrDbFromCorr(corr, peakIdx = lag, guard = 64)
                    val ok = snrDb >= 3.0 && d in 0.1..maxRangeM
                    runOnUiThread { b.txtDistance.text = if (ok) "~%.2f м  (FFT %.2f, SNR %.1f dB)".format(d,score,snrDb) else "— м" }
                    if (ok && snrDb > 6.0) vibrate(40)
                }
            }
            rec.stop(); rec.release()
        }
    }

    private fun stopRadar() { running = false; b.txtStatus.text = "Стоп" }

    private fun chirp(fs: Int, durMs: Int, fStart: Double, fEnd: Double): ShortArray {
        val n = fs * durMs / 1000
        val out = ShortArray(n)
        val k = (fEnd - fStart) / (durMs / 1000.0)
        for (i in 0 until n) {
            val t = i.toDouble() / fs
            val phase = 2.0 * Math.PI * (fStart * t + 0.5 * k * t * t)
            val s = 0.5 * kotlin.math.sin(phase)
            out[i] = (s * Short.MAX_VALUE).toInt().toShort()
        }
        return out
    }

    private fun vibrate(ms: Long) {
        val v = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        if (Build.VERSION.SDK_INT >= 26)
            v.vibrate(VibrationEffect.createOneShot(ms, VibrationEffect.DEFAULT_AMPLITUDE))
        else @Suppress("DEPRECATION") v.vibrate(ms)
    }

    override fun onDestroy() { super.onDestroy(); running = false; txThread?.interrupt(); rxThread?.interrupt() }
}</code></pre>
      </details>
    </div>

    <div class="foot">© AudioRadarFFT • HTML‑версия • Последнее обновление: <span id="ts"></span></div>
  </div>

  <script>
    // Простая анимация радара
    const c = document.getElementById('radar'); const ctx = c.getContext('2d'); let t=0;
    function draw(){
      const w=c.width,h=c.height,cx=w*0.5,cy=h*0.65,R=Math.min(w,h)*0.48;
      ctx.clearRect(0,0,w,h);
      for(let i=1;i<=4;i++){ctx.beginPath();ctx.arc(cx,cy,(R*i)/4,0,Math.PI*2);
        ctx.strokeStyle='rgba(160,200,255,0.18)';ctx.lineWidth=1;ctx.stroke()}
      ctx.beginPath();ctx.moveTo(cx-R,cy);ctx.lineTo(cx+R,cy);ctx.moveTo(cx,cy-R);ctx.lineTo(cx,cy+R);
      ctx.strokeStyle='rgba(160,200,255,0.12)';ctx.stroke();
      const ang=(t*0.02)%(Math.PI*2),sweep=Math.PI/18;
      const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,R);
      grad.addColorStop(0,'rgba(79,209,197,0.35)'); grad.addColorStop(1,'rgba(96,165,250,0.0)');
      ctx.beginPath();ctx.moveTo(cx,cy);ctx.arc(cx,cy,R,ang-sweep,ang+sweep);ctx.closePath();ctx.fillStyle=grad;ctx.fill();
      const r=R*0.55,ax=cx+r*Math.cos(ang*0.8),ay=cy+r*Math.sin(ang*0.8);
      ctx.beginPath();ctx.arc(ax,ay,4,0,Math.PI*2);ctx.fillStyle='#4fd1c5';ctx.fill();
      t++; requestAnimationFrame(draw);
    }
    draw();
    document.getElementById('ts').textContent=new Date().toLocaleString();
  </script>
</body>
</html>
